# -*- coding: utf-8 -*-
"""IFMG - Chamados de suporte 2019 a 2024.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13vwU-eO9Np2JK43egVPtxGfkqUc9YO6y

# **AnÃ¡lise descritiva e previsÃ£o de chamados de suporte - Instituto Federal de Minas Gerais (IFMG)**

Base de dados disponÃ­vel neste [link](https://dadosabertos.ifmg.edu.br/dataset/chamados-de-suporte).

# ðŸ”§ **ConfiguraÃ§Ãµes iniciais**

## ðŸ“š **Bibliotecas**
"""

import pandas as pd
import matplotlib.pyplot as plt
import numpy as np

"""ðŸ“˜ A funÃ§Ã£o `mean_absolute_error` e a funÃ§Ã£o `mean_squared_error`, ambas da biblioteca `sklearn.metrics`, sÃ£o usadas para medir a diferenÃ§a entre valores reais e valores previstos em problemas de regressÃ£o."""

from sklearn.metrics import mean_absolute_error, mean_squared_error

"""ðŸ“™ O **Prophet** Ã© uma ferramenta de modelagem de sÃ©ries temporais, projetada para fazer previsÃµes de sÃ©ries temporais com dados que apresentam padrÃµes sazonais e feriados."""

from prophet import Prophet

"""## ðŸ”— **Link de acesso ao dataset**"""

url = "http://dadosabertos.ifmg.edu.br/dataset/8339d8d9-deca-4de7-9070-aa5052975292/resource/a7efa452-03d9-435d-82f8-f7344516ad72/download/conjunto-de-dados-chamados-de-suporte.csv"

"""## ðŸŽ¯ **Carregando o dataset**"""

df = pd.read_csv(url)

"""# ðŸ“Š **AnÃ¡lise descritiva**

## ðŸ”¹ **Total de chamados por Ãrea da Universidade**
"""

total_por_area = df['area'].value_counts()
ax = total_por_area.plot(kind='bar', figsize=(12, 6))
plt.title('Total de Chamados por Ãrea da Universidade')
plt.xlabel('Ãrea')
plt.ylabel('Quantidade de Chamados')

# Ajustar a rotaÃ§Ã£o dos rÃ³tulos no eixo X
plt.xticks(rotation=65, ha='right')

# Adicionando os valores em cima das barras
for p in ax.patches:
    ax.annotate(str(p.get_height()), (p.get_x() + p.get_width() / 2, p.get_height()),
                ha='center', va='bottom', fontsize=10)

# Ajustando o limite do eixo Y para deixar mais espaÃ§o no topo
plt.ylim(0, total_por_area.max() * 1.2)

# Ajustar o espaÃ§amento inferior
plt.tight_layout()
plt.show()

"""## ðŸ”¹ **Total de chamados por Campus da Universidade**"""

total_por_area = df['campus'].value_counts()
ax = total_por_area.plot(kind='bar', figsize=(12, 6))
plt.title('Total de Chamados por Campus da Universidade')
plt.xlabel('Campus')
plt.ylabel('Quantidade de Chamados')

# Ajustar a rotaÃ§Ã£o dos rÃ³tulos no eixo X
plt.xticks(rotation=65, ha='right')

# Adicionando os valores em cima das barras
for p in ax.patches:
    ax.annotate(str(p.get_height()), (p.get_x() + p.get_width() / 2, p.get_height()),
                ha='center', va='bottom', fontsize=10)

# Ajustando o limite do eixo Y para deixar mais espaÃ§o no topo
plt.ylim(0, total_por_area.max() * 1.2)

# Ajustar o espaÃ§amento inferior
plt.tight_layout()
plt.show()

"""## ðŸ”¹ **Total de chamados por Ano (2019 a 2024)**"""

df['ano'] = pd.to_datetime(df['aberto-em'], dayfirst=True).dt.year
total_por_ano = df['ano'].value_counts().sort_index()

ax = total_por_ano.plot(kind='bar', figsize=(10, 6))
plt.title('Total de Chamados por Ano')
plt.xlabel('Ano')
plt.ylabel('Quantidade de Chamados')

# Ajustar a rotaÃ§Ã£o dos rÃ³tulos no eixo X e convertÃª-los para inteiros
ax.set_xticklabels(total_por_ano.index.astype(int), rotation=0)

# Adicionando os valores em cima das barras
for p in ax.patches:
    ax.annotate(str(p.get_height()), (p.get_x() + p.get_width() / 2, p.get_height()),
                ha='center', va='bottom', fontsize=10)

plt.tight_layout()
plt.show()

"""## ðŸ”¹ **Total de chamados Cancelados por Ãrea da Universidade**"""

cancelados_por_area = df[df['status'] == 'Cancelado']['area'].value_counts()
ax = cancelados_por_area.plot(kind='bar', figsize=(12, 6))
plt.title('Chamados Cancelados por Ãrea da Universidade')
plt.xlabel('Ãrea')
plt.ylabel('Quantidade de Chamados Cancelados')
# Ajustar a rotaÃ§Ã£o dos rÃ³tulos no eixo X
plt.xticks(rotation=65, ha='right')

# Ajustando o limite do eixo Y para deixar mais espaÃ§o no topo
plt.ylim(0, cancelados_por_area.max() * 1.2)

# Adicionando os valores em cima das barras
for p in ax.patches:
    ax.annotate(str(p.get_height()), (p.get_x() + p.get_width() / 2, p.get_height()),
                ha='center', va='bottom', fontsize=10)

plt.tight_layout()
plt.show()

"""## ðŸ”¹ **Total de chamados Cancelados por Campus da Universidade**"""

cancelados_por_campus = df[df['status'] == 'Cancelado']['campus'].value_counts()
ax = cancelados_por_campus.plot(kind='bar', figsize=(12, 6))
plt.title('Chamados Cancelados por Campus')
plt.xlabel('Campus')
plt.ylabel('Quantidade de Chamados Cancelados por Campus da Universidade')
# Ajustar a rotaÃ§Ã£o dos rÃ³tulos no eixo X
plt.xticks(rotation=65, ha='right')

# Ajustando o limite do eixo Y para deixar mais espaÃ§o no topo
plt.ylim(0, cancelados_por_campus.max() * 1.2)

# Adicionando os valores em cima das barras
for p in ax.patches:
    ax.annotate(str(p.get_height()), (p.get_x() + p.get_width() / 2, p.get_height()),
                ha='center', va='bottom', fontsize=10)

plt.tight_layout()
plt.show()

"""## ðŸ”¹ **Principais chamados por Grupo de ServiÃ§o - na Ã¡rea de Tecnologia da InformaÃ§Ã£o**"""

# Filtrar os dados onde a Ã¡rea Ã© "Tecnologia da InformaÃ§Ã£o"
df_ti = df[df['area'] == 'Tecnologia da InformaÃ§Ã£o']

# Contar os chamados por grupo de serviÃ§o e selecionar os 20 maiores
total_por_grupo_servico = df_ti['grupo-de-servico'].value_counts().head(20)

# Plotar o grÃ¡fico de barras
ax = total_por_grupo_servico.plot(kind='bar', figsize=(16, 6), color='skyblue')
plt.title('Principais chamados por Grupo de ServiÃ§o - Tecnologia da InformaÃ§Ã£o')
plt.xlabel('Grupo de ServiÃ§o')
plt.ylabel('Quantidade de Chamados')

# Ajustar a rotaÃ§Ã£o dos rÃ³tulos no eixo X
plt.xticks(rotation=45, ha='right')

# Adicionando os valores em cima das barras
for p in ax.patches:
    ax.annotate(str(p.get_height()), (p.get_x() + p.get_width() / 2, p.get_height()),
                ha='center', va='bottom', fontsize=10)

# Ajustar o limite do eixo Y para deixar mais espaÃ§o no topo
plt.ylim(0, total_por_grupo_servico.max() * 1.2)

# Ajustar o espaÃ§amento do layout
plt.tight_layout()
plt.show()

"""## ðŸ”¹ **Principais chamados por Grupo de ServiÃ§o - na Ã¡rea Administrativo**"""

# Filtrar os dados onde a Ã¡rea Ã© "Tecnologia da InformaÃ§Ã£o"
df_ti = df[df['area'] == 'Administrativo']

# Contar os chamados por grupo de serviÃ§o e selecionar os 20 maiores
total_por_grupo_servico = df_ti['grupo-de-servico'].value_counts().head(20)

# Plotar o grÃ¡fico de barras
ax = total_por_grupo_servico.plot(kind='bar', figsize=(16, 6), color='skyblue')
plt.title('Top 20 Chamados por Grupo de ServiÃ§o - Administrativo')
plt.xlabel('Grupo de ServiÃ§o')
plt.ylabel('Quantidade de Chamados')

# Ajustar a rotaÃ§Ã£o dos rÃ³tulos no eixo X
plt.xticks(rotation=45, ha='right')

# Adicionando os valores em cima das barras
for p in ax.patches:
    ax.annotate(str(p.get_height()), (p.get_x() + p.get_width() / 2, p.get_height()),
                ha='center', va='bottom', fontsize=10)

# Ajustar o limite do eixo Y para deixar mais espaÃ§o no topo
plt.ylim(0, total_por_grupo_servico.max() * 1.2)

# Ajustar o espaÃ§amento do layout
plt.tight_layout()
plt.show()

"""## ðŸ”¹ **Tempo mÃ©dio (em dias) para atendimento de chamados por Ãrea da Universidade**"""

# Converter colunas de datas para o formato datetime (com dayfirst=True)
df['aberto-em'] = pd.to_datetime(df['aberto-em'], dayfirst=True)
df['solucionado-em'] = pd.to_datetime(df['solucionado-em'], dayfirst=True)

# Filtrar apenas chamados com status "Fechado"
df_fechado = df[df['status'] == 'Fechado']

# Calcular o tempo de atendimento em dias com precisÃ£o decimal
df_fechado['tempo_atendimento'] = (df_fechado['solucionado-em'] - df_fechado['aberto-em']) / pd.Timedelta(days=1)

# Agrupar por 'area' e calcular o ticket mÃ©dio (mÃ©dia de tempo de atendimento)
ticket_medio_por_area = df_fechado.groupby('area')['tempo_atendimento'].mean().sort_values()

# Criar o grÃ¡fico
plt.figure(figsize=(12, 8))
bars = plt.bar(ticket_medio_por_area.index, ticket_medio_por_area.values)
plt.title('Tempo MÃ©dio de Tempo (em dias) de Atendimento por Ãrea')
plt.xlabel('Ãrea')
plt.ylabel('Tempo MÃ©dio de Atendimento (dias)')
# Ajustar a rotaÃ§Ã£o dos rÃ³tulos no eixo X
plt.xticks(rotation=45, ha='right')

# Adicionar os valores em cima de cada barra
for bar in bars:
    height = bar.get_height()
    plt.text(bar.get_x() + bar.get_width() / 2, height, f'{height:.2f}', ha='center', va='bottom')

# Ajustar o eixo Y para ser mais longo
plt.ylim(0, ticket_medio_por_area.max() * 1.2)

# Melhorar o layout
plt.tight_layout()
plt.show()

"""## ðŸ”¹ **Total de chamados abertos de janeiro a 19 de agosto de cada ano (2019 a 2024)**

O filtro de janeiro a 19 de agosto foi adicionado, pois o dataset do ano de 2024 contÃ©m dados apenas atÃ© essa data.
"""

# Garantir que a coluna 'aberto-em' esteja no formato de data
df['aberto-em'] = pd.to_datetime(df['aberto-em'], dayfirst=True)

# Criar um filtro para cada ano de janeiro atÃ© 19 de agosto
df_filtrado_2019 = df[(df['aberto-em'] >= '2019-01-01') & (df['aberto-em'] <= '2019-08-19')]
df_filtrado_2020 = df[(df['aberto-em'] >= '2020-01-01') & (df['aberto-em'] <= '2020-08-19')]
df_filtrado_2021 = df[(df['aberto-em'] >= '2021-01-01') & (df['aberto-em'] <= '2021-08-19')]
df_filtrado_2022 = df[(df['aberto-em'] >= '2022-01-01') & (df['aberto-em'] <= '2022-08-19')]
df_filtrado_2023 = df[(df['aberto-em'] >= '2023-01-01') & (df['aberto-em'] <= '2023-08-19')]
df_filtrado_2024 = df[(df['aberto-em'] >= '2024-01-01') & (df['aberto-em'] <= '2024-08-19')]

# Contar o nÃºmero de chamados por ano
total_2019 = len(df_filtrado_2019)
total_2020 = len(df_filtrado_2020)
total_2021 = len(df_filtrado_2021)
total_2022 = len(df_filtrado_2022)
total_2023 = len(df_filtrado_2023)
total_2024 = len(df_filtrado_2024)

# Criar uma lista com os totais para cada ano
totais = [total_2019, total_2020, total_2021, total_2022, total_2023, total_2024]
anos = ['2019', '2020', '2021', '2022', '2023', '2024']

# Criar o grÃ¡fico de barras
fig, ax = plt.subplots(figsize=(10, 6))
ax.bar(anos, totais)

# Adicionar os totais em cima de cada barra
for i in ax.patches:
    ax.annotate(f'{i.get_height()}',
                (i.get_x() + i.get_width() / 2, i.get_height()),
                ha='center', va='center',
                fontsize=10, color='black',
                xytext=(0, 5), textcoords='offset points')

# Ajustar tÃ­tulo e rÃ³tulos
plt.title('Total de Chamados Abertos de Janeiro atÃ© 19 de Agosto por Ano')
plt.xlabel('Ano')
plt.ylabel('NÃºmero de Chamados')

# Mostrar o grÃ¡fico
plt.show()

"""## ðŸ”¹ **Total de chamados cancelados de janeiro a 19 de agosto de cada ano (2019 a 2024)**

O filtro de janeiro a 19 de agosto foi adicionado, pois o dataset do ano de 2024 contÃ©m dados apenas atÃ© essa data.
"""

# Garantir que a coluna 'aberto-em' esteja no formato de data
df['aberto-em'] = pd.to_datetime(df['aberto-em'], dayfirst=True)

# Filtrar os chamados com status 'Cancelado'
df_cancelado = df[df['status'] == 'Cancelado']

# Criar um filtro para cada ano de janeiro atÃ© 19 de agosto para os chamados Cancelados
df_cancelado_2019 = df_cancelado[(df_cancelado['aberto-em'] >= '2019-01-01') & (df_cancelado['aberto-em'] <= '2019-08-19')]
df_cancelado_2020 = df_cancelado[(df_cancelado['aberto-em'] >= '2020-01-01') & (df_cancelado['aberto-em'] <= '2020-08-19')]
df_cancelado_2021 = df_cancelado[(df_cancelado['aberto-em'] >= '2021-01-01') & (df_cancelado['aberto-em'] <= '2021-08-19')]
df_cancelado_2022 = df_cancelado[(df_cancelado['aberto-em'] >= '2022-01-01') & (df_cancelado['aberto-em'] <= '2022-08-19')]
df_cancelado_2023 = df_cancelado[(df_cancelado['aberto-em'] >= '2023-01-01') & (df_cancelado['aberto-em'] <= '2023-08-19')]
df_cancelado_2024 = df_cancelado[(df_cancelado['aberto-em'] >= '2024-01-01') & (df_cancelado['aberto-em'] <= '2024-08-19')]

# Contar o nÃºmero de chamados cancelados por ano
total_cancelado_2019 = len(df_cancelado_2019)
total_cancelado_2020 = len(df_cancelado_2020)
total_cancelado_2021 = len(df_cancelado_2021)
total_cancelado_2022 = len(df_cancelado_2022)
total_cancelado_2023 = len(df_cancelado_2023)
total_cancelado_2024 = len(df_cancelado_2024)

# Criar uma lista com os totais de chamados cancelados para cada ano
totais_cancelado = [total_cancelado_2019, total_cancelado_2020, total_cancelado_2021, total_cancelado_2022, total_cancelado_2023, total_cancelado_2024]
anos = ['2019', '2020', '2021', '2022', '2023', '2024']

# Criar o grÃ¡fico de barras
fig, ax = plt.subplots(figsize=(10, 6))
ax.bar(anos, totais_cancelado)

# Adicionar os totais em cima de cada barra
for i in ax.patches:
    ax.annotate(f'{i.get_height()}',
                (i.get_x() + i.get_width() / 2, i.get_height()),
                ha='center', va='center',
                fontsize=10, color='black',
                xytext=(0, 5), textcoords='offset points')

# Ajustar tÃ­tulo e rÃ³tulos
plt.title('Total de Chamados Cancelados de Janeiro atÃ© 19 de Agosto por Ano')
plt.xlabel('Ano')
plt.ylabel('NÃºmero de Chamados Cancelados')

# Mostrar o grÃ¡fico
plt.show()

"""## ðŸ”¹ **Top 20 Grupos de ServiÃ§o com maior nÃºmero de chamados**"""

# Contar o nÃºmero de chamados por grupo de serviÃ§o
chamados_por_grupo = df['grupo-de-servico'].value_counts()

# Selecionar os 20 grupos com maior nÃºmero de chamados
top_20_grupos = chamados_por_grupo.head(20)

# Criar o grÃ¡fico de barras
fig, ax = plt.subplots(figsize=(16, 6))
top_20_grupos.plot(kind='bar', ax=ax)

# Adicionar os totais em cima de cada barra
for i in ax.patches:
    ax.annotate(f'{i.get_height()}',
                (i.get_x() + i.get_width() / 2, i.get_height()),
                ha='center', va='center',
                fontsize=10, color='black',
                xytext=(0, 5), textcoords='offset points')

# Ajustar o eixo Y para ser mais longo
plt.ylim(0, top_20_grupos.max() * 1.2)

# Ajustar tÃ­tulo e rÃ³tulos
plt.title('Top 20 Grupos de ServiÃ§o com Maior NÃºmero de Chamados')
plt.xlabel('Grupo de ServiÃ§o')
plt.ylabel('NÃºmero de Chamados')

# Mostrar o grÃ¡fico
plt.xticks(rotation=65, ha='right')  # Para garantir que os rÃ³tulos dos grupos sejam legÃ­veis
plt.show()

"""## ðŸ”¹ **ServiÃ§os mais frequentes no Grupo de ServiÃ§o RE-DTI-Redes e Internet**"""

# Filtrar os dados para incluir apenas os chamados do grupo "RE-DTI-Redes e Internet"
df_re_dti = df[df['grupo-de-servico'] == 'RE-DTI-Redes e Internet']

# Contar os 20 serviÃ§os mais frequentes no grupo "RE-DTI-Redes e Internet"
top_20_servicos = df_re_dti['servico'].value_counts().head(20)

# Criar o grÃ¡fico de barras para os 20 serviÃ§os mais frequentes
fig, ax = plt.subplots(figsize=(10, 6))
top_20_servicos.plot(kind='bar', ax=ax)

# Adicionar os totais em cima de cada barra
for i in ax.patches:
    ax.annotate(f'{i.get_height()}',
                (i.get_x() + i.get_width() / 2, i.get_height()),
                ha='center', va='center',
                fontsize=10, color='black',
                xytext=(0, 5), textcoords='offset points')

# Ajustar o eixo Y para ser mais longo
plt.ylim(0, top_20_servicos.max() * 1.2)

# Ajustar tÃ­tulo e rÃ³tulos
plt.title('ServiÃ§os Mais Frequentes no Grupo RE-DTI-Redes e Internet')
plt.xlabel('ServiÃ§o')
plt.ylabel('NÃºmero de Chamados')

# Mostrar o grÃ¡fico
plt.xticks(rotation=65, ha='right')  # Rotacionar os rÃ³tulos dos serviÃ§os para melhor legibilidade
plt.show()

"""# ðŸ“‰ **AnÃ¡lise de comportamento na abertura de chamados**

## ðŸ”¹ **Chamados diÃ¡rios ao longo do tempo**
"""

# Converter a coluna 'aberto-em' para datetime considerando o formato DD/MM/YYYY
df['aberto-em'] = pd.to_datetime(df['aberto-em'], dayfirst=True)

# Agrupar os dados por dia
df_daily = df.groupby(df['aberto-em'].dt.date).size().reset_index(name='chamados')

# Renomear a coluna de data para 'ds' (compatÃ­vel com Prophet)
df_daily.rename(columns={'aberto-em': 'ds', 'chamados': 'y'}, inplace=True)

# Visualizar os dados
plt.figure(figsize=(18, 6))
plt.plot(df_daily['ds'], df_daily['y'], label='Chamados DiÃ¡rios')
plt.title('Chamados DiÃ¡rios ao Longo do Tempo')
plt.xlabel('Data')
plt.ylabel('Quantidade de Chamados')
plt.legend()
plt.show()

"""## ðŸ”¹ **Chamados diÃ¡rios ao longo do tempo - na Ã¡rea de Tecnologia da InformaÃ§Ã£o**"""

# Filtrar os dados para incluir apenas os chamados da Ã¡rea 'Tecnologia da InformaÃ§Ã£o'
df_tecnologia = df[df['area'] == 'Tecnologia da InformaÃ§Ã£o']

# Converter a coluna 'aberto-em' para datetime
df_tecnologia['aberto-em'] = pd.to_datetime(df_tecnologia['aberto-em'])

# Agrupar os dados por dia
df_daily_tecnologia = df_tecnologia.groupby(df_tecnologia['aberto-em'].dt.date).size().reset_index(name='chamados')

# Renomear a coluna de data para 'ds' (compatÃ­vel com Prophet)
df_daily_tecnologia.rename(columns={'aberto-em': 'ds', 'chamados': 'y'}, inplace=True)

# Visualizar os dados
plt.figure(figsize=(18, 6))
plt.plot(df_daily_tecnologia['ds'], df_daily_tecnologia['y'], label='Chamados DiÃ¡rios - Tecnologia da InformaÃ§Ã£o')
plt.title('Chamados DiÃ¡rios ao Longo do Tempo - Tecnologia da InformaÃ§Ã£o')
plt.xlabel('Data')
plt.ylabel('Quantidade de Chamados')
plt.legend()
plt.show()

"""## ðŸ”¹ **Chamados diÃ¡rios ao longo do tempo - no campus Reitoria**"""

# Filtrar os dados para incluir apenas os chamados do campus 'REITORIA'
df_reitoria = df[df['campus'] == 'REITORIA']

# Converter a coluna 'aberto-em' para datetime
df_reitoria['aberto-em'] = pd.to_datetime(df_reitoria['aberto-em'])

# Agrupar os dados por dia
df_daily_reitoria = df_reitoria.groupby(df_reitoria['aberto-em'].dt.date).size().reset_index(name='chamados')

# Renomear a coluna de data para 'ds' (compatÃ­vel com Prophet)
df_daily_reitoria.rename(columns={'aberto-em': 'ds', 'chamados': 'y'}, inplace=True)

# Visualizar os dados
plt.figure(figsize=(18, 6))
plt.plot(df_daily_reitoria['ds'], df_daily_reitoria['y'], label='Chamados DiÃ¡rios - REITORIA')
plt.title('Chamados DiÃ¡rios ao Longo do Tempo - REITORIA')
plt.xlabel('Data')
plt.ylabel('Quantidade de Chamados')
plt.legend()
plt.show()

"""## ðŸ”¹ **PrevisÃ£o de chamados (360 dias)**"""

# Instanciar o modelo Prophet
model = Prophet()

# Ajustar o modelo aos dados
model.fit(df_daily)

# Criar um dataframe para previsÃµes (360 dias Ã  frente)
future = model.make_future_dataframe(periods=360)

# Gerar as previsÃµes
forecast = model.predict(future)

# Visualizar a previsÃ£o
fig = model.plot(forecast)
plt.title('PrevisÃ£o de Chamados DiÃ¡rios com Prophet')
plt.xlabel('Data')
plt.ylabel('Quantidade de Chamados')
plt.show()

# Exibir os componentes da sÃ©rie temporal (tendÃªncia, sazonalidade)
fig2 = model.plot_components(forecast)
plt.show()

"""**AvaliaÃ§Ã£o do modelo**"""

# Separar conjunto de teste (os Ãºltimos 360 dias)
train = df_daily[:-360]
test = df_daily[-360:]

# Ajustar o modelo com os dados de treino
model = Prophet()
model.fit(train)

# Fazer previsÃµes no perÃ­odo de teste
future_test = model.make_future_dataframe(periods=360)
forecast_test = model.predict(future_test)

# Filtrar previsÃµes para o conjunto de teste
forecast_test = forecast_test[-360:]

# Avaliar o modelo
y_test = test['y'].values
y_pred = forecast_test['yhat'].values

mae = mean_absolute_error(y_test, y_pred)
rmse = np.sqrt(mean_squared_error(y_test, y_pred))

print(f"MAE: {mae:.2f}")
print(f"RMSE: {rmse:.2f}")

"""## ðŸ”¹ **PrevisÃ£o de chamados (360 dias) na Ã¡rea de Tecnologia da InformaÃ§Ã£o**

"""

# Instanciar o modelo Prophet
model = Prophet()

# Ajustar o modelo aos dados filtrados
model.fit(df_daily_tecnologia)

# Criar um dataframe para previsÃµes (360 dias Ã  frente)
future_tec = model.make_future_dataframe(periods=360)

# Gerar as previsÃµes
forecast = model.predict(future_tec)

# Visualizar a previsÃ£o
fig = model.plot(forecast)
plt.title('PrevisÃ£o de Chamados DiÃ¡rios com Prophet - Tecnologia da InformaÃ§Ã£o')
plt.xlabel('Data')
plt.ylabel('Quantidade de Chamados')
plt.show()

# Exibir os componentes da sÃ©rie temporal (tendÃªncia, sazonalidade)
fig2 = model.plot_components(forecast)
plt.show()

"""**AvaliaÃ§Ã£o do modelo**"""

# Separar conjunto de treino
train = df_daily_tecnologia[:-360]
test = df_daily_tecnologia[-360:]

# Ajustar o modelo com os dados de treino
model = Prophet()
model.fit(train)

# Fazer previsÃµes no perÃ­odo de teste
future_test = model.make_future_dataframe(periods=360)
forecast_test = model.predict(future_test)

# Filtrar previsÃµes para o conjunto de teste
forecast_test = forecast_test[-360:]

# Avaliar o modelo
y_test = test['y'].values
y_pred = forecast_test['yhat'].values

# Calcular MAE e RMSE
mae = mean_absolute_error(y_test, y_pred)
rmse = np.sqrt(mean_squared_error(y_test, y_pred))

# Exibir as mÃ©tricas de avaliaÃ§Ã£o
print(f"MAE: {mae:.2f}")
print(f"RMSE: {rmse:.2f}")

"""## ðŸ”¹ **PrevisÃ£o de chamados (360 dias) no campus Reitoria**"""

# Instanciar o modelo Prophet
model = Prophet()

# Ajustar o modelo aos dados filtrados
model.fit(df_daily_reitoria)

# Criar um dataframe para previsÃµes (360 dias Ã  frente)
future_reitoria = model.make_future_dataframe(periods=360)

# Gerar as previsÃµes
forecast_reitoria = model.predict(future_reitoria)

# Visualizar a previsÃ£o
fig = model.plot(forecast_reitoria)
plt.title('PrevisÃ£o de Chamados DiÃ¡rios com Prophet - REITORIA')
plt.xlabel('Data')
plt.ylabel('Quantidade de Chamados')
plt.show()

# Exibir os componentes da sÃ©rie temporal (tendÃªncia, sazonalidade)
fig2 = model.plot_components(forecast_reitoria)
plt.show()

"""**AvaliaÃ§Ã£o do modelo**"""

# Separar conjunto de treino
train = df_daily_reitoria[:-360]
test = df_daily_reitoria[-360:]

# Ajustar o modelo com os dados de treino
model = Prophet()
model.fit(train)

# Fazer previsÃµes no perÃ­odo de teste
future_test = model.make_future_dataframe(periods=360)
forecast_test = model.predict(future_test)

# Filtrar previsÃµes para o conjunto de teste
forecast_test = forecast_test[-360:]

# Avaliar o modelo
y_test = test['y'].values
y_pred = forecast_test['yhat'].values

# Calcular MAE e RMSE
mae = mean_absolute_error(y_test, y_pred)
rmse = np.sqrt(mean_squared_error(y_test, y_pred))

# Exibir as mÃ©tricas de avaliaÃ§Ã£o
print(f"MAE: {mae:.2f}")
print(f"RMSE: {rmse:.2f}")